[
  {
    "objectID": "License.html",
    "href": "License.html",
    "title": "Cornelius Tanui",
    "section": "",
    "text": "corneliustanui.rbind.io © by Cornelius Tanui, 2024, licensed under CC BY-NC 4.0.\nrbind.io © by The Rbind Team, licensed under MIT License."
  },
  {
    "objectID": "License.html#website-and-content",
    "href": "License.html#website-and-content",
    "title": "Cornelius Tanui",
    "section": "",
    "text": "corneliustanui.rbind.io © by Cornelius Tanui, 2024, licensed under CC BY-NC 4.0.\nrbind.io © by The Rbind Team, licensed under MIT License."
  },
  {
    "objectID": "License.html#disclaimer",
    "href": "License.html#disclaimer",
    "title": "Cornelius Tanui",
    "section": "Disclaimer",
    "text": "Disclaimer\nThe views expressed here and on my website are my own and do not reflect the position of my employer or any organisation I am associated with."
  },
  {
    "objectID": "License.html#code-of-conduct",
    "href": "License.html#code-of-conduct",
    "title": "Cornelius Tanui",
    "section": "Code of Conduct",
    "text": "Code of Conduct\nThe content on this website is intended for educational and training purposes only, and is NOT by any means a platform to cause and perpetrate harm, destruction, prejudice, conflict, and any other outcome that can reasonably be considered harmful.\nBy visiting this website, you agree to abide by this moral, just, friendly, and charitable obligation.\nIn the event that whole or part of the content is considered inappropriate and/or offensive, contact the author for revision and update, or outright removal of the entire material."
  },
  {
    "objectID": "content/projects.html",
    "href": "content/projects.html",
    "title": "Projects",
    "section": "",
    "text": "1. Quick Stats Reporter(QSR)\nThis R Shiny web application is an extremely useful tool for quick data analysis and reporting. It determines on it’s own what kind of table and graph to generate depending on the type of variable(s) selected.\n\n\n2. 2019 KPHC Analytics\nAn R Shiny web dashboard application to demonstrate various findings of the 2019 Kenya Population and Housing Census. The app is auto-deployed using GitHub workflows and Docker CI/CD.\n\n\n3. miscellaneousR\nThis is an R package hosted on GitHub. The package contains convenient functions for performing simple to complex tasks appertaining to data wrangling."
  },
  {
    "objectID": "content/posts/2024-09-06/index.html",
    "href": "content/posts/2024-09-06/index.html",
    "title": "Kenyan Household Bands Classifier",
    "section": "",
    "text": "When I first heard of MTI, my immediate thought was that the government of Kenya had finally embraced Artificial Intelligence on a larger scale and decided to award university students scholarships based on economic bands decided by some novel AI algorithm. Think, a combination of classification algorithms of ‘repute compute, high repute’. A pleasant thought, right? No.\nNo because, later, I searched for MTI online and found out that it stands for ‘means testing instrument’, and if you are deep into data, you would think ‘means’ is hereby used to denote ‘average’. You see, ‘testing of means’ is not remotely uncommon, we come across it all the time in data analytics. T-test is a test of means, right? Right. I kid you not, ‘means’ in the context of MTI stands for ‘resources’, or ‘assets’, that a student has access to that could otherwise be used to fund their higher education. ‘Means’ can be a confusing word. Nonetheless, there are also ‘means of transport’, ‘by all means’, etc.\nAs it turned out, MTI is a widely used concept in the education and social protection sectors, and I was embarrassingly waaay off in thinking that it had something to do with statistical averages\nI was waaay off in yet another aspect – think about it for a moment; the students joining university in September, 2024 as first-years/freshmen had never been banded before, and therefore, there would be no training data for my imagined novel AI model! This is the first time banding is happening in Kenya, so maybe, just maybe, there will be (enough) data to train a model in 2025, so that the freshmen of 2025 will have successfully been banded by the AI.\n\n\n\nMTI has been around for a while now, with the first documented use in 1930s involving provision of relief to households by governments. If a home was deemed able to support itself by the source of income it had, the the government benefits were stopped or reduced1. MTI has since been heavily employed in the social protection sector to provide targeted anti-poverty benefits to households, civil legal aid to individuals2, communities, and geographies globally. The obvious reason for preference of MTI over universal provision of support – such as universal basic income – is that MTI offers the support to targeted beneficiaries, because with the universal approach, there may be recipients who do not genuinely require it3.\nIn Kenya, MTI has been used for a long time to identify households in marginalized communities that are eligible for benefit from cash transfers4 under the National Safety Net Programmes (NSNP). One such safety programme is the Hunger Safety Net Programme (HSNP) that supports old persons, orphans and vulnerable children, and persons with severe disability.\nLiterature indicates that MTI has worked successfully so far in Kenya as implemented under NSNP, but it is not without shortcomings. For example, the popular controversy around it is it discourages the target population from engaging in savings5, consequently promoting poverty, a concept known as ‘poverty trap’6. In Kenya, MTI sustained an unmitigated uproar over it’s banding inaccuracy that led to placement of students from poor backgrounds into higher bands7 that required them to dig deep into their pockets to fill the gap, pockets which they either do not have, or are torn. The bands run from 1 (least able) to 5 (most able.)\nUnder the hood, MTI is mainly a regression model – such as a tobit model – that aggregates various variables together and provides a value3 which is then compared to a threshold that determines whether the candidate qualifiers for the benefit or does not. Principal components analysis models have also been deployed to this cause4.\nNow, let us explore how an Artificial Intelligence classifier could be used as an alternative to MTI to award financial support to university students in Kenya."
  },
  {
    "objectID": "content/posts/2024-09-06/index.html#footnotes",
    "href": "content/posts/2024-09-06/index.html#footnotes",
    "title": "Kenyan Household Bands Classifier",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nvan Oorschot, W. J. H., & Schell, J. (1991). Means-testing in Europe: A growing concern. In M. Adler, C. Bell, J. Clasen, & A. Sinfield (Eds.), The sociology of social security (pp. 187-211). (Edinburgh education and society series). Edinburgh University Press.↩︎\nhttps://www.gov.uk/guidance/criminal-legal-aid-means-testing↩︎\nBrown, C., Ravallion, M., & Van de Walle, D. (2016). A poor means test. Econometric targeting in Africa. The World Bank.↩︎\nVilla, Juan M. [2016] A harmonised proxy means test for Kenya’s National Safety Net programme. GDI Working Paper 2016-003. Manchester: The University of Manchester.↩︎\nElizabeth T. Powers,Does means-testing welfare discourage saving? evidence from a change in AFDC policy in the United States, Journal of Public Economics, Volume 68, Issue 1, 1998, Pages 33-53, ISSN 0047-2727, https://doi.org/10.1016/S0047-2727(97)00087-X. (https://www.sciencedirect.com/science/article/pii/S004727279700087X)↩︎\nKraay, Aart, and David McKenzie. 2014. “Do Poverty Traps Exist? Assessing the Evidence.” Journal of Economic Perspectives, 28 (3): 127–48.↩︎\nhttps://www.citizen.digital/news/govt-explains-why-many-students-miss-out-on-scholarships-under-the-new-funding-model-n348207↩︎\nhttps://kafu.ac.ke/images/2022/Academics/nfm/NEW_FUNDING_MODEL_-_6TH_AUGUST_2024.pdf↩︎\nR Core Team (2021). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.↩︎\nKook, L., Herzog, L., Hothorn, T., Dürr, O., & Sick, B. (2022). Deep and interpretable regression models for ordinal outcomes. Pattern Recognition, 122, 108263.↩︎"
  },
  {
    "objectID": "content/blog.html",
    "href": "content/blog.html",
    "title": "Blog",
    "section": "",
    "text": "Introduction Statistical Data Simulation\n\n\n\n\n\n\nR\n\n\nsimulation\n\n\nmathematical statistical\n\n\n\nUsing Statistical Distributions to Generate Data that Mimics the Real World Scenario\n\n\n\n\n\nSep 12, 2024\n\n\nCornelius Tanui\n\n\n\n\n\n\n\n\n\n\n\n\nKenyan Household Bands Classifier\n\n\n\n\n\n\nR\n\n\nclassification\n\n\nprediction\n\n\nMTI\n\n\n\nPredicting the Household Economic Bands Into Which University Students Fall for Award of Financial Support from the Kenyan Government.\n\n\n\n\n\nSep 6, 2024\n\n\nCornelius Tanui\n\n\n\n\n\n\n\n\n\n\n\n\nModelling CPI Using ARIMA(p,d,q)\n\n\n\n\n\n\nR\n\n\ntime-series\n\n\nSmoothing\n\n\n\n\n\n\n\n\n\nJan 9, 2024\n\n\nCornelius Tanui\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/posts/2024-08-22/index.html",
    "href": "content/posts/2024-08-22/index.html",
    "title": "Modelling CPI Using ARIMA(p,d,q)",
    "section": "",
    "text": "1) Why CPI is Time Series\nConsumer Price Index (CPI) is defined as a measure of the weighted aggregate change in retail prices paid by consumers for a given basket of goods and services.\nThe CPI is a statistical indicator of changes in consumer prices experienced by citizens of a country. It is a measure that compares the cost of a fixed basket (234 items) of goods and services purchased by consumers over time. The CPI index reflects only pure price change and is a widely used to monitor the rate of inflation, which is the percentage change of CPI over one year (The Kenya National Bureau of Statistics (KNBS), 2010).\nCPI is a univariate non-stationary time series variable which does not have significant seasonality. Univariate because it is a single variable that predicts (or correlates to) itself based on its own history (auto-regressive) as opposed to an ordinary regression variable that is predicted by one or more variables of different nature. Furthermore, CPI is a time series variable since observed values are indexed in time. The fact that it naturally has an upward trend, possibly due to increasing population, changing lifestyles of people, and a generally growing economy means it is not stationary. Another important characteristic of CPI is periodicity. That is, observations are made more than once a year, in this case twelve times per year. This shows that CPIs are monthly realizations of onward (monotone increasing) right-continuous random variable in positive real line.\nThe data I will be using is obtained from KNBS and runs from March 1962 to September 2020.\n\n\n2) Loading the Required Packages\nThe following packages are required to perform this modelling; -\n\nlibrary(readxl)\nlibrary(tidyverse)\nlibrary(forecast)\nlibrary(tseries)\nlibrary(ggTimeSeries)\nlibrary(data.table)\nlibrary(here)\n\n\n\n3) Loading Data\n\n# import data\nCPI_Data &lt;- read_excel(here(\"./Data/Historical CPI series 2020.xlsx\"))\n\n# view data\nhead(CPI_Data, 10)\n\n# A tibble: 10 × 3\n   `MONTHLY CPI FROM 1962` ...2  ...3               \n   &lt;chr&gt;                   &lt;chr&gt; &lt;chr&gt;              \n 1 &lt;NA&gt;                    &lt;NA&gt;  &lt;NA&gt;               \n 2 Year                    Month Index              \n 3 1962                    Mar   0.47503449374032269\n 4 &lt;NA&gt;                    Jun   0.48014239152247667\n 5 &lt;NA&gt;                    Sep   0.48525028930463066\n 6 &lt;NA&gt;                    Dec   0.49035818708678469\n 7 1963                    Mar   0.48525028930463066\n 8 &lt;NA&gt;                    Jun   0.49035818708678469\n 9 &lt;NA&gt;                    Sep   0.50057398265109265\n10 &lt;NA&gt;                    Dec   0.50568188043324669\n\n\nThe column names are in row 2, this can be corrected as;\n\n# assign headers \ncolnames(CPI_Data) &lt;- CPI_Data[2, ]\n\n# drop records when Month is blank or has the string \"Month\"\nCPI_Data_clean &lt;- CPI_Data %&gt;% \n  filter(!is.na(Month) & Month != \"Month\")\n\n# fill in blank years\nCPI_Data_clean &lt;- CPI_Data_clean %&gt;% \n  fill(Year, .direction = \"down\") %&gt;% \n  mutate(Index = as.numeric(Index),\n         Year = as.numeric(Year))\n\n# view data\nhead(CPI_Data_clean, 10)\n\n# A tibble: 10 × 3\n    Year Month Index\n   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n 1  1962 Mar   0.475\n 2  1962 Jun   0.480\n 3  1962 Sep   0.485\n 4  1962 Dec   0.490\n 5  1963 Mar   0.485\n 6  1963 Jun   0.490\n 7  1963 Sep   0.501\n 8  1963 Dec   0.506\n 9  1964 Mar   0.501\n10  1964 Jun   0.501\n\n\n\n\n4) Declaring CPI as Time Series\n\nCPI_Data_ts &lt;- CPI_Data_clean %&gt;% \n  select(Year, Month, Index) %&gt;% \n  ts(start = c(1962, 3), \n        end = c(2020,9), \n        frequency = 1) \n\nclass(CPI_Data_ts)   # Check the class, technically this is a univariate ts\n\n[1] \"mts\"    \"ts\"     \"matrix\" \"array\" \n\n\n\n\n5) Visualisation of Trend\n\nCPI_Data_clean %&gt;% \n  # filter(Year &lt; 1984) %&gt;% \n  # mutate(Index = round(as.numeric(Index))) %&gt;% \n  ggplot(aes(x = Year, y = Index, colour = \"Data\")) + \n  geom_line(size = 0.5) +\n  geom_smooth(aes(color = \"Trend\"),\n              method = \"gam\", \n              size = 0.5,\n              lty = 2) +\n  scale_colour_manual(values = c(\"dodgerblue1\", \"maroon\")) +\n  scale_x_continuous(breaks = seq(1960, 2020, 5)) +\n  scale_y_continuous(breaks = seq(0, 110, 15)) +\n\n  labs(x = \"Year\",\n       y = \"CPI\",\n       title = \"CPI & It's Trend, 1962 to 2020\",\n       subtitle = \"The Trend is Approximated using GAM\",\n       caption = \"Figure 1\") +\n  \n  # custom theme\n      theme(plot.title = element_text(face = \"bold\",\n                                      hjust = 0.5,\n                                      size = 13.5,\n                                      family = \"serif\",\n                                      color = \"black\"),\n            plot.subtitle = element_text(face = \"italic\",\n                                      hjust = 0.5,\n                                      size = 9.5,\n                                      family = \"serif\",\n                                      color = \"black\"),\n            axis.title = element_text(face = \"bold\",\n                                      size = 11.5,\n                                      family = \"serif\",\n                                      color = \"black\"),\n            axis.text = element_text(face = \"plain\",\n                                     size = 10,\n                                     family = \"serif\",\n                                     color = \"black\"),\n            strip.text.x = element_text(face = \"bold\",\n                                        size = 13.5,\n                                        family = \"serif\",\n                                        color = \"black\"),\n            axis.text.x = element_text(angle = 0, \n                                       hjust = 1),\n            \n            legend.position = \"top\",\n            legend.title = element_blank(), \n            legend.text = element_text(face = \"plain\",\n                                       size = 10,\n                                       family = \"serif\",\n                                       color = \"black\"),\n            legend.key = element_rect(colour = NA, \n                                      fill = NA),\n            \n            legend.box = \"horizontal\",\n            legend.key.size = unit(0.5, 'cm'),\n            legend.spacing.x = unit(0.3, 'cm'),\n            legend.background = element_blank(),\n            \n            plot.background = element_rect(fill = \"white\",\n                                           color = \"black\", \n                                           linewidth = 1),\n            panel.grid = element_blank(),\n            panel.grid.minor.x = element_blank(),\n            panel.grid.major.x = element_blank(),\n            axis.line = element_line(color = \"black\"),\n            axis.ticks = element_line(color = \"black\"),\n            panel.background = element_blank()) +\n  guides(color = guide_legend(override.aes = list(fill = NA)))\n\n\n\n\n\n\n\n\nFigure 1 above shows upward rise in CPI over the years, the upwardness is indicative of trend, and therefore non-stationarity. This further implies that the CPI is constituted by multiplicative components; trend, seasonality, and random effects. Since it is multiplicative, applying log-transformation makes it easy to extract the random component by differencing, which also stabilizes variance and reduces seasonality. Even though the plot is ragged, seasonality is not immediately evident.\nTo extract seasonality, Seasonal Trend Loess decomposer (tslm()) is invoked. The decomposer, which works better than decompose(), is used for periodic time series, the periodicity (seasonal window) here is 4 months.\n\n\n6) Decomposition of CPI\n\nCPI_Data &lt;- ts(CPI_Data_clean$Index, start = c(1962, 3), end = c(2020, 9), frequency = 4)\n\ndecompose_df &lt;- tslm(CPI_Data ~ trend + fourier(CPI_Data, 2))\n\ntrend &lt;- coef(decompose_df)[1] + coef(decompose_df)['trend']*seq_along(CPI_Data)\n\ncomponents &lt;- cbind(\n  data = CPI_Data,\n  trend = trend,\n  season = CPI_Data - trend - residuals(decompose_df),\n  remainder = residuals(decompose_df))\n\nautoplot(components, facet = TRUE)\n\n\n\n\n\n\n\n\nThe plot above shows the individual components of CPI;\n\nTrend,\nSeasonality, and\nRandom error.\n\nHere, seasonal fluctuations are more evident. The trend has been smoothed, i.e. it is devoid of seasonality and random error. To explore seasonality:-\n\nadjust_df &lt;- CPI_Data - components[, 'season']\n\nautoplot(CPI_Data, series = \"Data\") +\n  autolayer(adjust_df, series = \"Seasonally adjusted\")\n\n\n\n\n\n\n\n\nIt is evident that the rate of consumption exponentially rose in the early ’80s to early ’90s. The sinusoidal aspect of seasonality is revealed by the plot below. Consumption goes down in April by a seasonal effect of 0.25 and goes up around July by an effect of 0.65 every year.\n\nplot(window(components[,3],\n            start = c(2016,1),\n            end = c(2018,1)),\n     main = \"Seasonlity of CPI, 2016 to 2018\",\n     xlab = \"Months\",\n     ylab = \"Effects\",\n     col = \"maroon\",\n     lwd = 2.5)\n\nabline(h = seq(-.7,.7,.1),\n       v = seq(2016, 2018, 1/12),\n       col = \"grey\",\n       lty = 2)\n\n\n\n\n\n\n\n\n\n\n7) Checking Normality Pictorially\n\ni) Stem and Leaf Plot\n\nstem(CPI_Data, scale = 1, width = 105)\n\n\n  The decimal point is at the |\n\n   0 | 5555555555555555555556666666666666666666677777788899\n   1 | 00001111223344445556678889\n   2 | 00334566899999\n   3 | 0011111222333444444567777777778899\n   4 | 000000111233444556777799\n   5 | 001122223466788899\n   6 | 02455788\n   7 | 0012344466\n   8 | 347\n   9 | 4555679\n  10 | 08\n  11 | 19\n  12 | 3\n  13 | 35\n  14 | 08\n  15 | 014\n  16 | 244777899\n  17 | 00111112234445678\n  18 | 1238\n  19 | 0\n\n\nThe above stem-and-leaf diagram shows the skewed distribution that CPI assumes. The skewness is to right.\n\n\nii) Histogram\nThe histogram in the figure below is skewed to the right, confirming what we found with the stem-and-leaf diagram. This skewness implies the data is not normally distributed. Furthermore, the skewness calls for log-transformation of the data.\n\nggplot(CPI_Data, aes(x = CPI_Data)) +\n  geom_histogram(aes(y = after_stat(density)),\n                 binwidth = 3, \n                 colour = \"black\", \n                 fill = \"maroon\")+\n  geom_density(alpha = .2, \n               fill = \"dodgerblue1\")+\n  labs(title = \"Distribution of CPI\",\n       x = \"CPI\", \n       y = \"Density\")+\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_continuous(expand = c(0,0))+\n  theme_classic()\n\n\n\n\n\n\n\n\nHistogram of Log Transformed CPI\n\nLoggedCPI &lt;- CPI_Data %&gt;% log()  \n  \nggplot(LoggedCPI, aes(x = LoggedCPI)) +\n  geom_histogram(aes(y = ..density..),\n                 binwidth = 0.1, \n                 colour = \"black\", \n                 fill = \"maroon\")+\n  geom_density(alpha = .2, \n               fill = \"dodgerblue1\")+\n  labs(title = \"Logged Distribution of CPI\",\n       x = \"CPI\", \n       y = \"Density\")+\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_continuous(expand = c(0,0))+\n  theme_classic()\n\n\n\n\n\n\n\n\nThe histogram above with a superimposed kernel density plot for CPI log-transgeomed gives a vague hint of a bimodal distribution. This needs further transformation.\n\n\niii) Q-Q Plot\nThe plot below clearly illustrates how far the CPI is from the normal distribution. QQ Plots compare observed data to standardized theoretical normal data. The closeness of the plot to straight line indicates the closeness of the observed data to being normally distributed. For our case, the CPI deviates away at the tails to form an S-curve that defies normality.\n\nggplot(CPI_Data, aes(sample=CPI_Data))+\n  stat_qq(color = \"maroon\")+\n  labs(title = \"Q-Q Plot of CPI\",\n       x = \"Theoretical\", \n       y = \"Sample\")+\n  theme_classic()\n\n\n\n\n\n\n\n\n\n\n\n8) Checking Normality Formally\n\ni) Jarque Bera Test\n\nCPI_Data %&gt;% jarque.bera.test() # From package \"tseries\"\n\n\n    Jarque Bera Test\n\ndata:  .\nX-squared = 57.318, df = 2, p-value = 3.577e-13\n\n\nThe hypothesis for this test is:-\n\n\\(H_0\\): CPI is normally distributed,\n\\(H_a\\): CPI is not normally distributed.\n\nHere, the p-value is smaller than 0.05 and thus we reject \\(H_0\\) and conclude at 95% level of confidence that CPI is indeed significantly skewed.\n\n\n\n9) Testing Stationarity Pictorially\n\na) Lagged Plots\nThe figure below shows plots of lags 1 to 20. The fact that there is a strong persistence of a straight line (autocorrelation) for lags above 20 excludes the dominance of an MA(q) in the series and gives a strong evidence for an AR(p). This persistence is due to the strong correlation (0.987) at lag one. This property is also called long memory. However, the series cannot be simply an AR(p) since the order of such an AR(p) would be too large a number and parsimony (idea of Occult’s Razor) would be violated. Therefore, the lagged plots give evidence of an ARMA(p,q) being the underlying best-case scenario.\n\nCPI_Data %&gt;% gglagplot(lag = 20, \n                       seasonal = TRUE) + \n    scale_color_viridis_d(option = \"viridis\") +\n  theme_light()\n\n\n\n\n\n\n\n\n\n\nb) ACF and PACF\nThe figure below is a correlogram of ACF and ACF of CPI for the first 80 lags. The slowly decaying property in ACF further gives evidence of the series being non-stationary and hence an AR(p). Because of the trend, the observations will usually be on the same side of the series’ global mean. The terms \\((X(t+k)−μ(X))(X(t)−μ(X))\\) are positive, for this reason, the ACF is positive as well and is close to one, i.e. 0.987 at lag 1. The smooth, linear decline in ACF also is an indicator of the insignificance of the seasonal effect in the series as opposed to a wave-like decline for the seasonally strong series. Notice that ACF comes to zero at lag about 78, this is too persistent an effect of long term memory.\nThe PACF cuts off immediately after the associated lag. This is typical of non-stationary processes.\n\nCPI_Data %&gt;% ggAcf(lag.max = 100,\n                   plot = TRUE) +\n  labs(title = \"CPI ACF\")+\n  theme_classic()\n\n\n\n\n\n\n\n\n\nCPI_Data %&gt;% ggPacf(lag.max = 100,\n                    plot = TRUE) +\n  labs(title = \"CPI PACF\")+\n  theme_classic()\n\n\n\n\n\n\n\n\n\n\n\n10) Testing Stationarity Formally\n\na) Augmented Dickey-Fuller Test (tests for unit root)\nThe Augmented Dickey-Fuller (ADF) Test has the following hypothesis:\n\n\\(H_0\\) Unit root exists (non-stationary)\n\\(H_1\\): No unit root Exists (stationary)\n\n\nadf.test(CPI_Data)\n\n\n    Augmented Dickey-Fuller Test\n\ndata:  CPI_Data\nDickey-Fuller = -0.52375, Lag order = 6, p-value = 0.9802\nalternative hypothesis: stationary\n\n\nWe fail to reject \\(H_0\\) at 95% confidence level because 0.9802 &gt; 0.05. The conclusion is that CPI for the period under study is not stationary. It follows from this conclusion that differencing is required to render the series stationary. As we have earlier deduced the underlying model to be ARMA(p,q), we now have a strong evidence for ARIMA (p,d,q) where d is the number of times required to difference to achieve stationarity.\n\n\nb) Ljung-Box Text (tests for white noise)\nTesting stationarity by checking whether the data is white noise, Ljung-Box (1978) test was made use of. The test is based on whether the sample autocorrelation is equal to zero:\n\n\\(H_0; ρ = 0\\) White noise\n\\(H_1; ρ ≠ 0\\) Not white noise.\n\nThis test follows a Chi-square distribution. If the p-value is less than 0.05 at lag \\(h\\) degrees of freedom, \\(H_0\\) is rejected and differencing is done.\nThe test statistic is given as; \\(Q(h) = n(n+2)∑^h _{k=1}\\frac{ρk}{(n−k)}\\)\n\nBox.test(CPI_Data, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  CPI_Data\nX-squared = 234.89, df = 1, p-value &lt; 2.2e-16\n\n\nClearly, the data is not white noise, we reject \\(H_0\\) and difference the data to achieve stationarity.\n\n\n\n11) Automatic Fitting of ARIMA(p,d,q)\nHaving established that CPI follows an ARIMA (p,d,q) model, we go ahead to find the best fitting model using AIC and BIC as the tools for choosing the parsimonious fit. The package forecast with appropriate dependencies installed, we are saved the trouble of transfoming the data to stabilize variance and seasonality before manually differencing.\n\nCPIfit &lt;- CPI_Data %&gt;% auto.arima(approximation = FALSE,\n                                  stepwise = FALSE,\n                                  trace = FALSE) # trace = TRUE will print all the possible models\nsummary(CPIfit)\n\nSeries: . \nARIMA(2,2,0)(2,0,1)[4] \n\nCoefficients:\n          ar1      ar2     sar1     sar2    sma1\n      -0.7461  -0.4174  -0.8993  -0.2587  0.8043\ns.e.   0.0610   0.0596   0.0983   0.0644  0.0831\n\nsigma^2 = 0.01867:  log likelihood = 137.05\nAIC=-262.1   AICc=-261.74   BIC=-241.29\n\nTraining set error measures:\n                      ME      RMSE        MAE        MPE     MAPE      MASE\nTraining set 0.002888028 0.1346216 0.06989758 0.08317552 1.286139 0.2097828\n                    ACF1\nTraining set -0.03239534\n\n\nNotice that by setting approximation = FALSE and stepwise = FALSE a more advanced/rigorous search for a model in conducted. The best model has the smallest BIC and AIC. The non-seasonal order (2,2,0) means the series has a moving average of order 0, an autoregressive component of order 2, and the ARMA is differenced twice (d = 2) to achieve stationarity. The mathematical model is the product of MA and AR components.\nA pure AR(p) model is one where \\(Y_t\\) depends only on its own lags. That is, \\(Y_t\\) is a function of the ‘lags of \\(Y_t\\)’:\n\\[Y_t=α+β_1Y_{t−1}+β_2Y_{t−2}+...β_pY_{t−p}+ϵ_1\\]\nA pure MA(q) is is one that \\(Y_t\\) depends only on the lagged forecast errors and is given by:\n\\[Y_t=α+ϵ_t+ϕ_1ϵ_{t−1}+ϕ_2ϵ_{t−2}+...ϕ_{t−q}\\]\nOverall, ARIMA becomes:\n\\[Y_t=α+β_1Y_t−1+β_2Y_{t−2}+...+β_pY_{t−p}ϵ_t+ϕ_1ϵ_{t−1}+ϕ_2ϵ_{t−2}+...+ϕ_qϵ_{t−q}\\] Substituting the coefficients, this becomes: \\[Y_t=α-0.7461Y_{t−1}-0.4174Y_{t−2}-0.8993ϵ_{t−1}-0.2587ϵ_{t−2}+0.8043ϵ_{t−3}\\]\n\na) Check Residuals for White Noise\n\ncheckresiduals(CPIfit)\n\n\n\n\n\n\n\n\n\n    Ljung-Box test\n\ndata:  Residuals from ARIMA(2,2,0)(2,0,1)[4]\nQ* = 5.0548, df = 3, p-value = 0.1678\n\nModel df: 5.   Total lags used: 8\n\n\nThere are a few significant spikes in the ACF, and the model fails the Ljung-Box test. The model can still be used for forecasting, but the prediction intervals may not be accurate due to the correlated residuals. Sometimes it is just not possible to find a model that passes all of the tests.\n\n\nb) Forecasting\n\nCPIforecast &lt;- CPIfit %&gt;% \n  forecast(h = 125,  # Forecast 5 (each with 4 seasons) years ahead of Sept 2020\n           level = c(95, 99))\n\n# summary(CPIforecast) # Print forecasts\n\n\n\nc) Visualising Forecasts\n\nCPIforecast %&gt;% autoplot() + theme_bw()\n\n\n\n\n\n\n\n\nThe point forcasts with both 95% CI and 99% CI are contained in summary(CPIforecast) for 33 years (each with 4 seasons) ahead of 2020, that is upto Q2 2053.\nEnd\nNote: This post was first published by the author on RPubs in 2019."
  },
  {
    "objectID": "content/posts/2024-09-12/index.html",
    "href": "content/posts/2024-09-12/index.html",
    "title": "Introduction Statistical Data Simulation",
    "section": "",
    "text": "0.0.0.1 Data Simulation\n\n\nCode\n# load packages\nlibrary(here)\nlibrary(tidyverse)\n\n\nSimulation of data used by the Government in MTI to place university students into 5 bands for award of Government scholarship\n\n\n\n\n\n\nDisclaimer!\n\n\n\n\n\nThe data is simulated, and therefore substantially differs with the actual scenario! The data is for learning purposes only, and the statistical estimates reported MUST NOT be taken as true reflection of the real-word situation.\n\n\n\n\n\nCode\n# table display setup\n#| label: tbl-simulated_data .striped .hover .primary .bordered\n#| tbl-cap: \"Simulated data\"\n#| tbl-cap-location: bottom \n\n# for reproducibility\nset.seed(1) \n\n# generate data\nsimulated_data &lt;- data.frame(Bands = rbinom(n = 1000, \n                                        size = 5, \n                                        prob = 0.5),\n                         Gross_Family_Income = rnbinom(n = 1000, \n                                                         size = 5, \n                                                         mu = 20000),\n                         Geographical_Location = as.factor(ceiling(runif(n = 1000, \n                                                                           min = 1, \n                                                                           max = 47))),\n                         Poverty_Probability_Index = abs(rnorm(n = 1000, \n                                                                 mean = 0.3, \n                                                                 sd = 0.2)),\n                         Orphans = as.factor(rbinom(n = 1000,\n                                                    size = 1,\n                                                    prob = 0.4)),\n                         Disability = as.factor(rbinom(n = 1000,\n                                                       size = 1,\n                                                       prob = 0.022)),\n                         Number_of_Dependents = rpois(n = 1000, \n                                                        lambda = 4),\n                         Program_Costs_KES = abs(rnorm(n = 1000,\n                                                     mean = 500000,\n                                                     sd = 50000)),\n                         Gender = as.factor(rbinom(n = 1000,\n                                                   size = 3,\n                                                   prob = 0.017)))\n\n# view data (printed on your browser)\nknitr::kable(head(x = simulated_data, n = 5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBands\nGross_Family_Income\nGeographical_Location\nPoverty_Probability_Index\nOrphans\nDisability\nNumber_of_Dependents\nProgram_Costs_KES\nGender\n\n\n\n\n2\n18621\n36\n0.1751991\n1\n0\n4\n510735.4\n0\n\n\n2\n6235\n39\n0.2081443\n1\n0\n5\n466547.2\n0\n\n\n3\n33812\n33\n0.5994036\n0\n0\n3\n458893.0\n0\n\n\n4\n30154\n22\n0.3511708\n0\n0\n3\n554462.2\n0\n\n\n2\n27145\n14\n0.1675043\n0\n0\n5\n464203.2\n1\n\n\n\n\n\nCode\n# write data to disc\nwrite.csv(x = simulated_data, row.names = FALSE, file = here::here(\"./Data/simulated_data.csv\"))\nsaveRDS(object = simulated_data, file = here::here(\"./Data/simulated_data.rds\"))"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cornelius Tanui",
    "section": "",
    "text": "I am a skilled data professional with over 5 years of experience in public health, renewable energy, WASH, climate action, and clinical trials.\nHaving a B.Sc. in Applied Statistics with Computing, I have worked as a Data Analyst, Statistician, Statistical Trainer, Data Manager, and currently as an FSP Data Configurations Engineer."
  }
]